;; Copyright 2019 Matthew Egan Odendahl
;; SPDX-License-Identifier: Apache-2.0

;; bootstrap _define helper function using builtins
(operator..setitem (globals) \' _define
                   (lambda (name value)
                     (operator..setitem (globals)
                                        name
                                        value)))

;; boostrap _tuple helper function using _define
(_define \' _tuple
         (lambda (: :* elements)
           elements))

;; macro namespace
(_define \' _macro_ (types..SimpleNamespace))

;; define require-as macro
(setattr _macro_ \' require-as
         (lambda (macro name)
           (_tuple \' builtins..setattr
                   \' (.setdefault (builtins..globals)
                                   \' _macro_
                                   (types..SimpleNamespace))
                   (_tuple \' quote name)
                   macro)))

;; create defmacro
(require-as (lambda (name args : :* body)
              (_tuple \' hissp.basic.._macro_.require-as
                      (_tuple \' lambda args : :* body)
                      name))
            defmacro)

(defmacro tuple* (: :* xs)
  (_tuple \'(lambda (: :* a) a) : :* xs))

(defmacro define (name value)
  (tuple*
   \' operator..setitem
   \' (builtins..globals)
   (tuple* \' quote name)
   value))

(defmacro if-else (b then otherwise)
  (tuple*
   \' (lambda (b : :* then-else)
        ((operator..getitem then-else (operator..not_ b))))
   b
   (tuple* \' lambda () then)
   (tuple* \' lambda () otherwise)))

(define test2
    (lambda (b)
      (if-else b
               (print \' yes)
               (print \' no))))

(print \' basic)

(defmacro do (: :* body)
  (tuple*
   (tuple* \' lambda ()
           : :* body)))

(defmacro let (pairs : :* body)
  (tuple*
   (tuple* \' lambda (tuple* ":" : :* pairs)
           : :* body)))

(let (x 1
      y 2)
  (print x y))
;; Cond?
;; ` , ,@
