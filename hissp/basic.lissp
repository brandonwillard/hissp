;; Copyright 2019 Matthew Egan Odendahl
;; SPDX-License-Identifier: Apache-2.0

;; bootstrap macro namespace using builtins
(operator..setitem (globals) '_macro_ (types..SimpleNamespace)

;; define require-as macro
(setattr _macro_ 'require-as
         (lambda (macro name)
           `(builtins..setattr
             (.setdefault (builtins..globals)
                          ','_macro_
                          (types..SimpleNamespace))
             (quote ,name)
             ,macro)))

;; create defmacro
(require-as (lambda (name args : :* body)
              `(hissp.basic.._macro_.require-as
                  (lambda ,args ,@body)
                  ,name))
            defmacro)

(defmacro define (name value)
  `(operator..setitem (builtins..globals)
                      ',name
                      ,value))

(defmacro if-else (b then otherwise)
  `((lambda (,'b : :* ,'then-else)
      ((operator..getitem ,'then-else (operator..not_ ,'b))))
    ,b
    (lambda () ,then)
    (lambda () ,otherwise)))


(defmacro progn (: :* body)
  `((lambda ()
      ,@body)))

(defmacro let (pairs : :* body)
  `((lambda (: ,@pairs)
      ,@body)))

;; some basic tests follow

(define test2
    (lambda (b)
      (if-else b
               (print 'yes)
               (print 'no))))

(progn
  (define spam 40)
  (print 'basic)
  (test2 1)
  (test2 0)
  (let (x spam
        y 2)
    (print x y)))

;; Cond?
